# -*- coding: utf-8 -*-
"""image_alignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wp1COd9anBc_B9vNXX5jHEpTi8XR-8YC

# Step 4: Image Alignment Using Homography
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def extract_features(image, method):
    """
    Extract keypoints and descriptors from an image using the specified method.

    :param image: Input image
    :param method: 'SIFT', 'SURF', or 'ORB'
    :return: keypoints, descriptors
    """
    if method == 'SIFT':
        detector = cv2.SIFT_create()
    elif method == 'SURF':
        detector = cv2.xfeatures2d.SURF_create()  # Note: This might not work in newer OpenCV versions
    elif method == 'ORB':
        detector = cv2.ORB_create()
    else:
        raise ValueError("Unsupported method. Choose 'SIFT', 'SURF', or 'ORB'.")

    keypoints, descriptors = detector.detectAndCompute(image, None)
    return keypoints, descriptors

def match_features(desc1, desc2, method):
    """
    Match features using either Brute-Force or FLANN.

    :param desc1: Descriptors from the first image
    :param desc2: Descriptors from the second image
    :param method: 'BF' for Brute-Force or 'FLANN' for FLANN-based matcher
    :return: List of good matches
    """
    if method == 'BF':
        matcher = cv2.BFMatcher(cv2.NORM_L2, crossCheck=True)
        matches = matcher.match(desc1, desc2)
        good_matches = sorted(matches, key=lambda x: x.distance)
    elif method == 'FLANN':
        FLANN_INDEX_KDTREE = 1
        index_params = dict(algorithm=FLANN_INDEX_KDTREE, trees=5)
        search_params = dict(checks=50)
        matcher = cv2.FlannBasedMatcher(index_params, search_params)
        matches = matcher.knnMatch(desc1, desc2, k=2)
        good_matches = []
        for m, n in matches:
            if m.distance < 0.7 * n.distance:
                good_matches.append(m)
    else:
        raise ValueError("Unsupported method. Choose 'BF' or 'FLANN'.")

    return good_matches

def align_images(img1, img2, feature_method='SIFT', matching_method='FLANN'):
    """
    Align img2 to img1 using feature matching and homography.

    :param img1: Reference image
    :param img2: Image to be aligned
    :param feature_method: Method for feature extraction ('SIFT', 'SURF', or 'ORB')
    :param matching_method: Method for feature matching ('BF' or 'FLANN')
    :return: Aligned image
    """
    # Extract features
    kp1, desc1 = extract_features(img1, feature_method)
    kp2, desc2 = extract_features(img2, feature_method)

    # Match features
    good_matches = match_features(desc1, desc2, matching_method)

    # Extract matched keypoints
    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)

    # Compute homography
    M, mask = cv2.findHomography(dst_pts, src_pts, cv2.RANSAC, 5.0)

    # Apply homography to align img2 to img1
    h, w = img1.shape[:2]
    aligned_img = cv2.warpPerspective(img2, M, (w, h))

    return aligned_img

def display_alignment_results(img1, img2, aligned_img):
    """
    Display original images and aligned image.

    :param img1: Reference image
    :param img2: Image to be aligned
    :param aligned_img: Aligned image
    """
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 8))

    ax1.imshow(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB))
    ax1.set_title('Reference Image')
    ax1.axis('off')

    ax2.imshow(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB))
    ax2.set_title('Image to be Aligned')
    ax2.axis('off')

    ax3.imshow(cv2.cvtColor(aligned_img, cv2.COLOR_BGR2RGB))
    ax3.set_title('Aligned Image')
    ax3.axis('off')

    plt.tight_layout()
    plt.show()

# Usage example
img1 = cv2.imread('NEWTON_1.webp')
img2 = cv2.imread('NEWTON_2.webp')
aligned_img = align_images(img1, img2, feature_method='SIFT', matching_method='FLANN')
display_alignment_results(img1, img2, aligned_img)

# Display All
if __name__ == "__main__":
    # Load images
    img1 = cv2.imread('NEWTON_1.webp')
    img2 = cv2.imread('NEWTON_2.webp')

    # Align images
    aligned_img = align_images(img1, img2)

    # Display results
    display_alignment_results(img1, img2, aligned_img)

    # Optionally, save the aligned image
    cv2.imwrite('aligned_image.jpg', aligned_img)